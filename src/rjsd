#!/usr/bin/env node

// "use strict";

/*global require, process, __filename, setTimeout*/

var safe = require('safetydance');
var rjs = require('./rjs');
var log = require('./log');
var Args = require('./Args');
var Daemon = require('./Daemon');

var daemon = new Daemon;

var pendingStdIn = '';
process.stdin.on('readable', function() {
    function formatXML(tag, str)
    {
        // if (str.indexOf('\n')
        // return "<" + tag + " length=\"" + str.length + "\">" + str + "</" + tag + ">";
        return '<' + tag + '>' + str + '</' + tag + '>';
    }

    var read = process.stdin.read();
    log.verboseLog('Got stdin', read);
    if (!read)
        return;
    pendingStdIn += read;
    var lines = pendingStdIn.split('\n');
    if (lines.length > 1) {
        for (var i=0; i<lines.length - 1; ++i) {
            var commands;
            if (!lines[i])
                continue;
            if (lines[i][0] === '-') {
                var parsed = Args.parseArgs(lines[i].split(/ +/), rjs.clientParseArgsOptions);
                if (parsed.help) {
                    log.writeResponse(formatXML('help', rjs.clientUsageString));
                    continue;
                }
                commands = rjs.createCommands(parsed);
            } else {
                commands = [ safe.JSON.parse(lines[i]) ];
            }
            if (!commands.length) {
                log.writeResponse(formatXML('error' ,'Unknown command: ' + lines[i]));
                continue;
            }
            log.verboseLog(commands);

            commands.forEach(function(msg) {
                daemon.processMessage(msg, function(response) {
                    log.verboseLog('processing message', msg);
                    function write(funcOrString) {
                        if (!funcOrString)
                            return;
                        var out;
                        if (funcOrString instanceof Function) {
                            out = funcOrString();
                        } else {
                            out = funcOrString;
                        }
                        // if (out)
                        //     out += '\n';
                        log.writeResponse(formatXML(msg.type, out));
                    }
                    if (response.type == rjs.MESSAGE_ERROR) {
                        write(response.text);
                    } else if (response.target) {
                        write(rjs.printLocation({ location: response.target }));
                    } else if (response.references || response.locations) {
                        write(function() {
                            var fileCache = {};
                            var locs = response.references || response.locations;
                            var ret = [];
                            locs.forEach(function(loc) {
                                ret.push(rjs.printLocation({ location: loc, showContext: true, fileCache: fileCache }));
                            });
                            return ret.join('\n');
                        });
                    } else if (response.hasOwnProperty('dump')) {
                        write(response.dump);
                    } else if (response.cursorInfo) {
                        write(function() {
                            var ret = [ rjs.printLocation({ location: response.cursorInfo.location }) ];
                            ret.push('Name: ' + response.cursorInfo.name + (response.cursorInfo.definition ? ' Definition' : ' Reference'));
                            if (response.cursorInfo.references && response.cursorInfo.references.length) {
                                var fileCache = {};
                                ret.push('References:');
                                response.cursorInfo.references.forEach(function(loc) {
                                    ret.push(rjs.printLocation({location: loc, header: '  ',
                                                                fileCache: fileCache, showContext: true }));
                                });
                            }
                            return ret.join('\n');
                        });
                    } else if (response.symbolNames) {
                        write(response.symbolNames.join('\n'));
                    } else if (response.type == rjs.MESSAGE_INDEX) {
                        log.verboseLog('Got index', response);
                    } else if (response.error != rjs.ERROR_OK) {
                        log.verboseLog('Got error', response);
                    } else {
                        console.error('Unknown response', response);
                    }
                });
            });
        }
        pendingStdIn = lines[lines.length - 1] || '';
    }
});
