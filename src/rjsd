#!/usr/bin/env node

// "use strict";

/*global require, process, RJS, __filename*/

var safe = require('safetydance');
var fs = require('fs');
var ws = require('ws');
var rjs = require('./rjs.js');
var expandTile = require('expand-tilde');
var indexer = require('./indexer.js');
var preprocessor = require('./preprocessor.js');
var parseArgs = require('minimist');
var usageString = ('Usage:\n$0 ...options\n' +
                   '-v|--verbose\n' +
                   '-h|--help\n' +
                   '-l|--logfile\n' +
                   '-s|--silent\n' +
                   '-p|--port [default ' + rjs.defaultPort + ']\n');
var parseArgsOptions = {
    alias: {
        l: 'logfile',
        v: 'verbose',
        p: 'port',
        h: 'help',
        s: 'silent'
    },
    default: {
        p: rjs.defaultPort
    }
};
var args = parseArgs(process.argv.slice(2), parseArgsOptions);

var outputs = [
    {
        log: function(str) { console.error(str); },
        verbosity: args.silent ? 0 : args.verbose ? 2 : 1
    }
];

if (args.logfile) {
    var output = {
        log: function(str) {
            if (str[str.length - 1] != '\n')
                str += '\n';
            fs.appendFile(args.logfile, str, function (err) {});
        },
        verbosity: 2
    };
    outputs.push(output);
}

function addLog(conn, verbose) {
    var output = {
        log: function(str) {
            conn.send(JSON.stringify({type: rjs.MESSAGE_LOG, log: str, error: rjs.ERROR_MORE_DATA }));
        },
        verbosity: verbose ? 2 : 1,
        connection: conn
    };

    outputs.push(output);
}

function removeLog(conn) {
    for (var i=0; i<outputs.length; ++i) {
        if (outputs[i].connection == conn) {
            outputs.splice(i, 1);
            break;
        }
    }
}

function sendToOutput(verbosity, str)
{
    if (!str)
        return;
    for (var i=0; i<outputs.length; ++i) {
        if (outputs[i].verbosity >= verbosity) {
            outputs[i].log(str);
        }
    }
}

function formatLog(args) {
    var out = '';
    function add(obj) {
        var str;
        if (obj instanceof Object) {
            try {
                str = JSON.stringify(obj);
            } catch (err) {
            }
        }
        if (!str) {
            str = '' + obj;
        }
        if (out.length && out[out.length - 1] != ' ')
            out += ' ';
        out += str;
    }
    for (var i=0; i<args.length; ++i) {
        add(args[i]);
    }
    return out;
}

function writeResponse() { sendToOutput(0, formatLog(arguments)); }
function log() { sendToOutput(1, formatLog(arguments)); }
function verboseLog() { sendToOutput(2, formatLog(arguments)); }

function exit(code, message, showUsage)
{
    function log(out) {
        if (code) {
            console.error(out);
        } else {
            console.log(out);
        }
    }

    if (showUsage) {
        log(usageString.replace('$0', __filename));
    }
    if (message)
        log(message);
    process.exit(code);
}

(function() {
    if (args['_'].length)
        exit(1, 'Invalid arguments', true);
    var validArgs = {};
    var arg;
    for (arg in parseArgsOptions.alias) {
        validArgs[arg] = true;
        validArgs[parseArgsOptions.alias[arg]] = true;
    }
    for (arg in args) {
        if (arg != '_' && args.hasOwnProperty(arg) && !validArgs[arg])
            exit(1, 'Unrecognized argument ' + arg, true);
    }
    if (args['file'] instanceof Array)
        exit(1, 'Too many --file arguments', true);
    if (args['help']) {
        exit(0, '', true);
    }
})();


if (args.help) {
    exit(0, '', true);
}

var db = {};
var server = new ws.Server({ port:args.port });
server.on('error', function(err) {
    log('Got error', err);
    process.exit(1);
});

function processMessage(msg, chunked, sendFunc) {
    var msgType;
    function send(obj) {
        if (!obj.error)
            obj.error = rjs.ERROR_OK;
        if (typeof msgType !== 'undefined')
            obj.type = msgType;
        sendFunc(obj);
        verboseLog('sending', obj);
    }

    verboseLog('got message', msg);
    if (!msg) {
        send({error: rjs.ERROR_PROTOCOL_ERROR});
        return;
    }
    msgType = msg.type;
    switch (msg.type) {
    case rjs.MESSAGE_COMPILE:
        var fileName = msg.file;
        msg = undefined;
        if (!fileName) {
            send({error: rjs.ERROR_MISSING_FILE});
            return;
        }
        if (db[fileName]) {
            var stat = safe.fs.statSync(fileName);
            if (!stat) {
                send({error: rjs.ERROR_STATFAILURE});
                return;
            }
            if (stat.mtime <= db[fileName].indexTime) {
                send({error: rjs.ERROR_FILE_ALREADY_INDEXED});
                return;
            }
        }
        function index(output) {
            log('index', fileName);
            var start = new Date();
            var source;
            var indexTime = new Date();
            try {
                source = preprocessor.preprocess(fileName);
            } catch (err) {
                console.error('Couldn\'t preprocess', fileName, 'for reading', err.toString());
                if (output)
                    send({error: rjs.ERROR_READFAILURE});
                return false;
            }
            if (output)
                send({});

            var ret = indexer.indexFile(source.code, fileName, args.verbose);
            if (!ret) {
                console.error('Couldn\'t parse file', fileName);
                return false;
            }
            log('Indexed', fileName, 'in', (new Date() - start), 'ms', ret.symbols.length, 'symbols and', ret.symbolNames.length, 'symbol names');

            console.log(ret.symbolNames);
            verboseLog(ret);
            ret.indexTime = indexTime;
            var split = {};
            // console.log(JSON.stringify(ret, undefined, 4));
            function resolveLocation(arr, cmp, addFile) {
                var resolved = preprocessor.resolveLocation(arr[0], source.files);
                // console.log("resolving ", arr[0], resolved, cmp, addFile, (resolved.file == cmp));
                if (resolved.file != cmp) {
                    var diff = arr[0] - resolved.index;
                    arr[0] = resolved.index;
                    arr[1] -= diff;
                    if (addFile) {
                        arr[3] = resolved.file;
                    }
                }
                return resolved;
            }
            for (var i=0; i<ret.symbols.length; ++i) {
                var sym = ret.symbols[i];
                sym.location = sym.location.slice();
                var loc = resolveLocation(sym.location, fileName, false);
                // console.log(loc);
                if (sym.references) {
                    for (var r=0; r<sym.references.length; ++r) {
                        sym.references[r] = sym.references[r].slice();
                        resolveLocation(sym.references[r], loc.file, true);
                    }
                }

                if (sym.target) {
                    sym.target = sym.target.slice();
                    resolveLocation(sym.target, loc.file, true);
                }
                if (loc.file !== fileName) {
                    var diff = sym.location[0] - loc.index;
                    sym.location[0] = loc.index;
                    sym.location[1] -= diff;
                }
                if (!split[loc.file]) {
                    split[loc.file] = { symbols: [ sym ], symbolNames: {} };
                } else {
                    split[loc.file].symbols.push(sym);
                }
            }
            // need to resolve symbolnames
            for (var symbolName in ret.symbolNames) {
                // var locations = ret.symbolNames
            }

            for (var f in split) {
                db[f] = split[f];
            }
            // ### need to resolve locations in ret to the various preprocessed files
            console.log(JSON.stringify(db, undefined, 4));
            return true;
        };
        if (index(true)) {
            var onFileModified = function() {
                var cached = db[fileName];
                verboseLog(fileName, 'was modified');
                if (!cached) {
                    fs.unwatch(fileName, onFileModified);
                    return;
                }
                var stat = safe.fs.statSync(fileName);
                if (!stat) {
                    fs.unwatch(fileName, onFileModified);
                    return;
                }
                verboseLog(fileName, 'was modified', stat.mtime, cached.indexTime);
                if (stat.mtime > cached.indexTime) {
                    index(false);
                }
            };
            fs.watch(fileName, onFileModified);
        }
        break;

    case rjs.MESSAGE_FOLLOW_SYMBOL:
    case rjs.MESSAGE_FIND_REFERENCES:
    case rjs.MESSAGE_CURSOR_INFO:
        if (!msg.location || !msg.location.file || !msg.location.offset) {
            send({error: rjs.ERROR_INVALID_LOCATION});
            break;
        }
        if (!db[msg.location.file]) {
            send({error: rjs.ERROR_FILE_NOT_INDEXED});
            break;
        }
        var result = indexer.findLocation(db[msg.location.file].symbols, msg.location.offset);
        if (!result) {
            send({error: rjs.ERROR_SYMBOL_NOT_FOUND});
            break;
        }
        function createLocation(loc) {
            return loc ? { file: msg.location.file, offset: loc[0] } : {};
        }
        verboseLog('Found symbol', result);
        if (msg.type === rjs.MESSAGE_FOLLOW_SYMBOL) {
            send({ target: createLocation(result.symbol.target) });
        } else if (msg.type === rjs.MESSAGE_CURSOR_INFO) {
            send({ cursorInfo: result.symbol });
        } else {
            var startLoc = result.pos;
            if (!result.symbol.definition && result.symbol.target) {
                var sym = indexer.findLocation(db[msg.location.file].symbols, result.symbol.target[0]);
                if (sym)
                    result = sym;
            }
            var references = result.symbol.references;
            var refs = [];
            if (references) {
                for (var idx=0; idx<result.symbol.references.length - 1; ++idx) { // if the current is the last in the array there's no reason to resort
                    if (result.symbol.references[idx][0] === startLoc) {
                        references = result.symbol.references.slice(idx + 1).concat(result.symbol.references.slice(0, idx + 1));
                        break;
                    }
                }
                references.forEach(function(value) { refs.push(createLocation(value)); });
            }

            send({ references: refs });
        }
        break;

    case rjs.MESSAGE_FIND_SYMBOLS:
        if (!msg.symbolName) {
            send({error: rjs.ERROR_MISSING_SYMBOLNAME});
            break;
        }

        var locations = [];
        function addLocations(file) {
            var ret = indexer.findSymbolsByName(db[file].symbolNames, msg.symbolName);
            if (ret) {
                for (var i=0; i<ret.locations.length; ++i) {
                    locations.push({ file: file, offset: ret.locations[i][0] });
                }
            }
        }
        if (msg.file) {
            if (!db[msg.file]) {
                send({error: rjs.ERROR_FILE_NOT_INDEXED});
                break;
            }
            addLocations(msg.file);
        } else {
            for (var f in db) {
                addLocations(f);
            }
        }
        locations.sort();
        send({ locations: locations });
        break;

    case rjs.MESSAGE_LIST_SYMBOLS:
        var symbolNameObject = {};
        var symbolNameArray = [];
        function listSymbols(symbolNames) {
            var ret = indexer.listSymbols(symbolNames, msg.prefix);
            verboseLog('Got results', ret);
            for (var i=0; i<ret.symbolNames.length; ++i) {
                var name = ret.symbolNames[i];
                if (!symbolNameObject[name]) {
                    symbolNameObject[name] = true;
                    symbolNameArray.push(name);
                }
            }
        }
        if (msg.file) {
            if (!db[msg.file]) {
                send({error: rjs.ERROR_FILE_NOT_INDEXED});
                break;
            }
            listSymbols(db[msg.file].symbolNames);
        } else {
            for (var file in db) {
                listSymbols(db[file].symbolNames);
            }
        }
        symbolNameArray.sort();
        send({ symbolNames: symbolNameArray });
        break;

    case rjs.MESSAGE_DUMP:
        if (msg.file) {
            if (!db[msg.file]) {
                send({error: rjs.ERROR_FILE_NOT_INDEXED});
                break;
            }
            send({ dump: JSON.stringify(db[msg.file], null, 4) });
        } else {
            var dump = '';
            for (var ff in db) {
                var entry = db[ff];
                if (chunked) {
                    send({ error: rjs.ERROR_MORE_DATA, dump: ff + " " + entry.indexTime });
                } else {
                    if (dump)
                        dump += '\n';
                    dump += ff + ' ' + entry.indexTime;
                }
            }
            if (dump) {
                send({ dump: dump });
            } else {
                send({});
            }
        }
        break;
    case rjs.MESSAGE_ERROR:
        send({error: rjs.ERROR_BAD_COMMAND, text: msg.error});
        break;
    default:
        send({error: rjs.ERROR_UNKNOWN_COMMAND});
        break;
    }
}

server.on('connection', function(conn) {
    verboseLog('Got a connection');
    conn.on('close', function(message) {
        if (conn.log) {
            removeLog(conn);
        }
        conn = undefined;
    });
    conn.on('message', function(message) {
        var msg = safe.JSON.parse(message);
        verboseLog('got message', msg);
        if (msg.type == rjs.MESSAGE_LOG) {
            conn.log = true;
            addLog(conn, msg.verbose);
        } else {
            processMessage(safe.JSON.parse(message), true, function(data) {
                if (conn)
                    conn.send(JSON.stringify(data));
            });
        }
    });
});

function formatXML(tag, str)
{
    // if (str.indexOf('\n')
    // return "<" + tag + " length=\"" + str.length + "\">" + str + "</" + tag + ">";
    return '<' + tag + '>' + str + '</' + tag + '>';
}

var pendingStdIn = '';
process.stdin.on('readable', function() {
    var read = process.stdin.read();
    verboseLog('Got stdin', read);
    if (!read)
        return;
    pendingStdIn += read;
    var lines = pendingStdIn.split('\n');
    if (lines.length > 1) {
        for (var i=0; i<lines.length - 1; ++i) {
            var commands;
            if (!lines[i])
                continue;
            if (lines[i][0] === '-') {
                var parsed = parseArgs(lines[i].split(/ +/), rjs.clientParseArgsOptions);
                if (parsed.help) {
                    writeResponse(formatXML('help', rjs.clientUsageString));
                    continue;
                }
                commands = rjs.createCommands(parsed);
            } else {
                commands = [safe.JSON.parse(lines[i])];
            }
            if (!commands.length) {
                writeResponse(formatXML('error' ,'Unknown command: ' + lines[i]));
                continue;
            }
            verboseLog(commands);

            commands.forEach(function(msg) {
                processMessage(msg, false, function(response) {
                    verboseLog('processing message', msg);
                    function write(funcOrString) {
                        if (!funcOrString)
                            return;
                        var out;
                        if (funcOrString instanceof Function) {
                            out = funcOrString();
                        } else {
                            out = funcOrString;
                        }
                        // if (out)
                        //     out += '\n';
                        writeResponse(formatXML(msg.type, out));
                    }
                    if (response.type == rjs.MESSAGE_ERROR) {
                        write(response.text);
                    } else if (response.target) {
                        write(rjs.printLocation({ location: response.target }));
                    } else if (response.references || response.locations) {
                        write(function() {
                            var fileCache = {};
                            var locs = response.references || response.locations;
                            var ret = [];
                            locs.forEach(function(loc) {
                                ret.push(rjs.printLocation({ location: loc, showContext: true, fileCache: fileCache }));
                            });
                            return ret.join('\n');
                        });
                    } else if (response.hasOwnProperty('dump')) {
                        write(response.dump);
                    } else if (response.cursorInfo) {
                        write(function() {
                            var ret = [ rjs.printLocation({ location: response.cursorInfo.location }) ];
                            ret.push('Name: ' + response.cursorInfo.name + (response.cursorInfo.definition ? ' Definition' : ' Reference'));
                            if (response.cursorInfo.references && response.cursorInfo.references.length) {
                                var fileCache = {};
                                ret.push('References:');
                                response.cursorInfo.references.forEach(function(loc) {
                                    ret.push(rjs.printLocation({location: loc, header: '  ',
                                                                fileCache: fileCache, showContext: true }));
                                });
                            }
                            return ret.join('\n');
                        });
                    } else if (response.symbolNames) {
                        write(response.symbolNames.join('\n'));
                    } else if (response.type == rjs.MESSAGE_COMPILE) {
                        verboseLog('Got compile', response);
                    } else if (response.error != rjs.ERROR_OK) {
                        verboseLog('Got error', response);
                    } else {
                        console.error('Unknown response', response);
                    }
                });
            });
        }
        pendingStdIn = lines[lines.length - 1] || '';
    }
});
