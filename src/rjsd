#!/usr/bin/env node

// "use strict";

/*global require, process, RJS, __filename, os*/

var safe = require('safetydance');
var fs = require('fs');
var ws = require('ws');
var rjs = require('./rjs');
var Database = require('./Database');
var expandTile = require('expand-tilde');
var indexFile = require('./indexFile');
var preprocessor = require('./preprocessor.js');
var parseArgs = require('minimist');
var os = require('os');
var defaultDataDir = os.homedir() + '/.rjsd';
var usageString = ('Usage:\n$0 ...options\n' +
                   '-v|--verbose\n' +
                   '-h|--help\n' +
                   '-l|--logfile\n' +
                   '-s|--silent\n' +
                   '-C|--clear\n' +
                   '-D|--data-dir [default: ' + defaultDataDir + ' ]\n' +
                   '-q|--quit-after-commands\n' +
                   '-p|--port [default: ' + rjs.defaultPort + ' ]\n');
var log = require('./log');
var parseArgsOptions = {
    alias: {
        l: 'logfile',
        v: 'verbose',
        p: 'port',
        h: 'help',
        s: 'silent',
        q: 'quit-after-commands',
        C: 'clear',
        D: 'data-dir',
    },
    default: {
        p: rjs.defaultPort,
        D: defaultDataDir
    }
};
var args = parseArgs(process.argv.slice(2), parseArgsOptions);

log.addSink(new log.Sink(console.error.bind(console), args.silent ? 0 : args.verbose ? 2 : 1));

if (args.logfile) {
    function logFile(str) {
        if (str[str.length - 1] != '\n')
            str += '\n';
        fs.appendFile(args.logfile, str, function (err) {});
    }
    log.addSink(new log.Sink(logFile, 2));
}

function addLog(conn, verbose) {
    var output = {
        log: function(str) {
            conn.send(JSON.stringify({type: rjs.MESSAGE_LOG, log: str, error: rjs.ERROR_MORE_DATA }));
        },
        verbosity: verbose ? 2 : 1,
        connection: conn
    };

    function logger(str) {
        conn.send(JSON.stringify({type: rjs.MESSAGE_LOG, log: str, error: rjs.ERROR_MORE_DATA }));
    }
    var sink = new log.Sink(logger, verbose ? 2 : 1);
    sink.conn = conn;
    log.addSink(sink);
}

function removeLog(conn) {
    for (var i=0; i<log.outputs.length; ++i) {
        if (log.outputs[i].connection == conn) {
            log.outputs.splice(i, 1);
            break;
        }
    }
}

function exit(code, message, showUsage)
{
    function log(out) {
        if (code) {
            console.error(out);
        } else {
            console.log(out);
        }
    }

    if (showUsage) {
        log(usageString.replace('$0', __filename));
    }
    if (message)
        log(message);
    process.exit(code);
}

(function() {
    if (args['_'].length)
        exit(1, 'Invalid arguments', true);
    var validArgs = {};
    var arg;
    for (arg in parseArgsOptions.alias) {
        validArgs[arg] = true;
        validArgs[parseArgsOptions.alias[arg]] = true;
    }
    for (arg in args) {
        if (arg != '_' && args.hasOwnProperty(arg) && !validArgs[arg])
            exit(1, 'Unrecognized argument ' + arg, true);
    }
    if (args['file'] instanceof Array)
        exit(1, 'Too many --file arguments', true);
    if (args['help']) {
        exit(0, '', true);
    }
})();


if (args.help) {
    exit(0, '', true);
}

var db = {};
var server = new ws.Server({ port:args.port });
server.on('error', function(err) {
    log.log('Got error', err);
    process.exit(1);
});

function processMessage(msg, chunked, sendFunc) {
    var f;
    var msgType;
    function send(obj) {
        if (!obj.error)
            obj.error = rjs.ERROR_OK;
        if (typeof msgType !== 'undefined')
            obj.type = msgType;
        if (sendFunc
            sendFunc(obj);
        log.verboseLog('sending', obj);
    }

    log.verboseLog('got message', msg);
    if (!msg) {
        send({error: rjs.ERROR_PROTOCOL_ERROR});
        return;
    }
    msgType = msg.type;
    switch (msg.type) {
    case rjs.MESSAGE_COMPILE:
        var fileName = msg.file;
        msg = undefined;
        if (!fileName) {
            send({error: rjs.ERROR_MISSING_FILE});
            return;
        }
        if (db[fileName]) {
            var stat = safe.fs.statSync(fileName);
            if (!stat) {
                send({error: rjs.ERROR_STATFAILURE});
                return;
            }
            if (stat.mtime <= db[fileName].indexTime) {
                send({error: rjs.ERROR_FILE_ALREADY_INDEXED});
                return;
            }
        }
        function index(fromWatcher) {
            log.log('index', fileName);
            var start = new Date();
            var source = preprocessor.preprocess(fileName);
            if (!source) {
                console.error('Couldn\'t preprocess', fileName);
                if (!fromWatcher)
                    send({error: rjs.ERROR_READFAILURE});
                return false;
            }
            // console.log(source);
            if (!fromWatcher)
                send({});

            var ret = indexFile(source, args.verbose);
            if (!ret) {
                console.error('Couldn\'t parse file', fileName);
                return undefined;
            }
            // log.log('Indexed', fileName, 'in', (new Date() - start), 'ms', ret.symbols.length, 'symbols and', ret.symbolNames.length, 'symbol names');

            // console.log(ret.symbolNames);
            log.verboseLog(ret);
            // console.log(JSON.stringify(db, undefined, 4));
            return ret;
        };
        var files = index(false);
        if (files) {
            function createOnFileModified(file) {
                var func = function() {
                    var cached = db[file];
                    log.verboseLog(file, 'was modified');
                    if (!cached) {
                        fs.unwatch(file, func);
                        return;
                    }
                    var stat = safe.fs.statSync(file);
                    if (!stat) {
                        fs.unwatch(file, func);
                        return;
                    }
                    log.verboseLog(file, 'was modified', stat.mtime, cached.indexTime);
                    if (stat.mtime > cached.indexTime) {
                        index(true);
                    }
                };
                return func;
            }

            for (var file in files) {
                db[file] = files[file];
                fs.watch(file, createOnFileModified(file));
            }
        }
        break;

    case rjs.MESSAGE_FOLLOW_SYMBOL:
    case rjs.MESSAGE_FIND_REFERENCES:
    case rjs.MESSAGE_CURSOR_INFO:
        if (!msg.location || !msg.location.file || !msg.location.offset) {
            log.verboseLog("rjs.ERROR_INVALID_LOCATION");
            send({error: rjs.ERROR_INVALID_LOCATION});
            break;
        }
        if (!db[msg.location.file]) {
            log.verboseLog("rjs.ERROR_FILE_NOT_INDEXED");
            send({error: rjs.ERROR_FILE_NOT_INDEXED});
            break;
        }
        var result = db[msg.location.file].findSymbol(msg.location.offset);
        if (!result) {
            log.verboseLog("rjs.ERROR_SYMBOL_NOT_FOUND");
            send({error: rjs.ERROR_SYMBOL_NOT_FOUND});
            break;
        }
        function createLocation(loc) {
            return loc ? { file: loc.file, offset: loc.start } : {};
        }
        log.verboseLog('Found symbol', result);
        if (msg.type === rjs.MESSAGE_FOLLOW_SYMBOL) {
            send({ target: createLocation(result.symbol.target) });
        } else if (msg.type === rjs.MESSAGE_CURSOR_INFO) {
            send({ cursorInfo: result.symbol });
        } else {
            var startLoc = result.pos;
            if (!result.symbol.definition && result.symbol.target) {
                var sym = db[msg.location.file].findSymbol(result.symbol.target[0]);
                if (sym)
                    result = sym;
            }
            var references = result.symbol.references;
            var refs = [];
            if (references) {
                for (var idx=0; idx<result.symbol.references.length - 1; ++idx) { // if the current is the last in the array there's no reason to resort
                    if (result.symbol.references[idx][0] === startLoc) {
                        references = result.symbol.references.slice(idx + 1).concat(result.symbol.references.slice(0, idx + 1));
                        break;
                    }
                }
                references.forEach(function(value) { refs.push(createLocation(value)); });
            }

            send({ references: refs });
        }
        break;

    case rjs.MESSAGE_FIND_SYMBOLS:
        if (!msg.symbolName) {
            send({error: rjs.ERROR_MISSING_SYMBOLNAME});
            break;
        }

        var locations = [];
        function addLocations(file) {
            var ret = db[file].findSymbolsByName(msg.symbolName);
            if (ret) {
                for (var i=0; i<ret.locations.length; ++i) {
                    locations.push({ file: file, offset: ret.locations[i][0] });
                }
            }
        }
        if (msg.file) {
            if (!db[msg.file]) {
                send({error: rjs.ERROR_FILE_NOT_INDEXED});
                break;
            }
            addLocations(msg.file);
        } else {
            for (f in db) {
                addLocations(f);
            }
        }
        locations.sort();
        send({ locations: locations });
        break;

    case rjs.MESSAGE_LIST_SYMBOLS:
        var symbolNameObject = {};
        var symbolNameArray = [];
        function listSymbols(db) {
            var ret = db.listSymbols(msg.prefix);
            log.verboseLog('Got results', ret);
            for (var i=0; i<ret.symbolNames.length; ++i) {
                var name = ret.symbolNames[i];
                if (!symbolNameObject[name]) {
                    symbolNameObject[name] = true;
                    symbolNameArray.push(name);
                }
            }
        }
        if (msg.file) {
            if (!db[msg.file]) {
                send({error: rjs.ERROR_FILE_NOT_INDEXED});
                break;
            }
            listSymbols(db[msg.file]);
        } else {
            for (f in db) {
                listSymbols(db[f]);
            }
        }
        symbolNameArray.sort();
        send({ symbolNames: symbolNameArray });
        break;

    case rjs.MESSAGE_DUMP:
        if (msg.file) {
            if (!db[msg.file]) {
                send({error: rjs.ERROR_FILE_NOT_INDEXED});
                break;
            }
            send({ dump: JSON.stringify(db[msg.file], null, 4) });
        } else {
            var dump = '';
            for (var ff in db) {
                var entry = db[ff];
                if (chunked) {
                    send({ error: rjs.ERROR_MORE_DATA, dump: ff + " " + entry.indexTime });
                } else {
                    if (dump)
                        dump += '\n';
                    dump += ff + ' ' + entry.indexTime;
                }
            }
            if (dump) {
                send({ dump: dump });
            } else {
                send({});
            }
        }
        break;
    case rjs.MESSAGE_ERROR:
        send({error: rjs.ERROR_BAD_COMMAND, text: msg.error});
        break;
    default:
        send({error: rjs.ERROR_UNKNOWN_COMMAND});
        break;
    }
}

server.on('connection', function(conn) {
    log.verboseLog('Got a connection');
    conn.on('close', function(message) {
        if (conn.log) {
            removeLog(conn);
        }
        conn = undefined;
    });
    conn.on('message', function(message) {
        var msg = safe.JSON.parse(message);
        log.verboseLog('got message', msg);
        if (msg.type == rjs.MESSAGE_LOG) {
            conn.log = true;
            addLog(conn, msg.verbose);
        } else {
            processMessage(safe.JSON.parse(message), true, function(data) {
                if (conn)
                    conn.send(JSON.stringify(data));
            });
        }
    });
});

var pendingStdIn = '';
process.stdin.on('readable', function() {
    function formatXML(tag, str)
    {
        // if (str.indexOf('\n')
        // return "<" + tag + " length=\"" + str.length + "\">" + str + "</" + tag + ">";
        return '<' + tag + '>' + str + '</' + tag + '>';
    }

    var read = process.stdin.read();
    log.verboseLog('Got stdin', read);
    if (!read)
        return;
    pendingStdIn += read;
    var lines = pendingStdIn.split('\n');
    if (lines.length > 1) {
        for (var i=0; i<lines.length - 1; ++i) {
            var commands;
            if (!lines[i])
                continue;
            if (lines[i][0] === '-') {
                var parsed = parseArgs(lines[i].split(/ +/), rjs.clientParseArgsOptions);
                if (parsed.help) {
                    log.writeResponse(formatXML('help', rjs.clientUsageString));
                    continue;
                }
                commands = rjs.createCommands(parsed);
            } else {
                commands = [safe.JSON.parse(lines[i])];
            }
            if (!commands.length) {
                log.writeResponse(formatXML('error' ,'Unknown command: ' + lines[i]));
                continue;
            }
            log.verboseLog(commands);

            commands.forEach(function(msg) {
                processMessage(msg, false, function(response) {
                    log.verboseLog('processing message', msg);
                    function write(funcOrString) {
                        if (!funcOrString)
                            return;
                        var out;
                        if (funcOrString instanceof Function) {
                            out = funcOrString();
                        } else {
                            out = funcOrString;
                        }
                        // if (out)
                        //     out += '\n';
                        log.writeResponse(formatXML(msg.type, out));
                    }
                    if (response.type == rjs.MESSAGE_ERROR) {
                        write(response.text);
                    } else if (response.target) {
                        write(rjs.printLocation({ location: response.target }));
                    } else if (response.references || response.locations) {
                        write(function() {
                            var fileCache = {};
                            var locs = response.references || response.locations;
                            var ret = [];
                            locs.forEach(function(loc) {
                                ret.push(rjs.printLocation({ location: loc, showContext: true, fileCache: fileCache }));
                            });
                            return ret.join('\n');
                        });
                    } else if (response.hasOwnProperty('dump')) {
                        write(response.dump);
                    } else if (response.cursorInfo) {
                        write(function() {
                            var ret = [ rjs.printLocation({ location: response.cursorInfo.location }) ];
                            ret.push('Name: ' + response.cursorInfo.name + (response.cursorInfo.definition ? ' Definition' : ' Reference'));
                            if (response.cursorInfo.references && response.cursorInfo.references.length) {
                                var fileCache = {};
                                ret.push('References:');
                                response.cursorInfo.references.forEach(function(loc) {
                                    ret.push(rjs.printLocation({location: loc, header: '  ',
                                                                fileCache: fileCache, showContext: true }));
                                });
                            }
                            return ret.join('\n');
                        });
                    } else if (response.symbolNames) {
                        write(response.symbolNames.join('\n'));
                    } else if (response.type == rjs.MESSAGE_COMPILE) {
                        log.verboseLog('Got compile', response);
                    } else if (response.error != rjs.ERROR_OK) {
                        log.verboseLog('Got error', response);
                    } else {
                        console.error('Unknown response', response);
                    }
                });
            });
        }
        pendingStdIn = lines[lines.length - 1] || '';
    }
    if (args['quit-after-commands'])
        process.exit();
});

function deleteFolderRecursive(path)
{
    var files = [];
    if( fs.existsSync(path) ) {
        files = fs.readdirSync(path);
        files.forEach(function(file,index){
            var curPath = path + "/" + file;
            if(fs.lstatSync(curPath).isDirectory()) { // recurse
                deleteFolderRecursive(curPath);
            } else { // delete file
                fs.unlinkSync(curPath);
            }
        });
        fs.rmdirSync(path);
    }
}


console.log(args['data-dir']);
var indexed;
if (args.clear) {
    deleteFolderRecursive(args['data-dir']);
} else {
    var contents = safe.fs.readFileSync(args['data-dir'] + '/indexed.json');
    if (contents) {
        indexed = safe.JSON.parse(contents);
    }
}
safe.fs.mkdirSync(args['data-dir']);
if (indexed && indexed.files instanceof Array) {
    indexed.files.forEach(function(file) {

    });
}
// console.log(indexed);
